# 博客服务架构设计

## 架构演进

### 为什么选择微服务架构

**单体架构的问题**

- ❌ 代码耦合度高，修改一处影响全局
- ❌ 单点故障风险，一个模块崩溃导致整体不可用
- ❌ 扩展性差，只能整体扩容，无法针对单个模块
- ❌ 技术栈固定，难以引入新技术

**微服务架构的优势**

- ✅ 服务独立开发、部署、扩展
- ✅ 故障隔离，单个服务异常不影响整体
- ✅ 技术栈多样化，每个服务可选择最适合的技术
- ✅ 团队协作更高效，不同团队负责不同服务

## 微服务设计原则

### 1. 单一职责原则

每个服务只负责一个业务领域，职责清晰。

### 2. 高内聚低耦合

服务内部高内聚，服务间低耦合，通过 RPC 通信。

### 3. 独立部署能力

每个服务可独立部署、升级和扩展。

### 4. 数据隔离

每个服务管理自己的数据，避免数据耦合。

## 服务模块划分

### 核心服务

| 服务名称       | 职责范围 | 主要功能                       |
|------------|------|----------------------------|
| Account    | 用户管理 | 用户注册、登录认证、信息管理、第三方登录       |
| Permission | 权限管理 | RBAC 权限模型、角色管理、菜单管理、API 鉴权 |
| Article    | 内容管理 | 文章 CRUD、分类标签、评论点赞、搜索功能     |
| Message    | 互动管理 | 评论系统、留言板、聊天室、消息通知          |
| Resource   | 资源管理 | 文件上传、图片处理、OSS 存储、CDN 加速    |
| Website    | 网站管理 | 访问统计、页面配置、SEO 优化、友链管理      |
| Config     | 配置中心 | 系统配置、参数管理、配置热更新            |
| Log        | 日志管理 | 操作日志、访问日志、异常日志、日志分析        |

### 服务架构图

```
┌──────────────────────────────────────────────────────┐
│                    Blog API 服务                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ Account  │  │ Article  │  │ Message  │  ...      │
│  │ 用户服务  │  │  文章服务 │   │  消息服务 │           │
│  └──────────┘  └──────────┘  └──────────┘           │
└───────────────────────┬──────────────────────────────┘
                        │ gRPC 调用
                        ┼            
                        │                    
                    ┌───▼────┐     
                    │Blog RPC│                  
                    │        │                   
                    └────────┘                  
```

## 技术架构

### 后端技术栈

- **框架**：Go-zero（微服务框架）
- **通信**：gRPC（服务间通信）
- **数据库**：MySQL（关系型数据库）
- **缓存**：Redis（缓存服务）
- **消息队列**：RabbitMQ/Kafka（异步处理）
- **服务发现**：ETCD（服务注册发现）
- **配置中心**：Nacos（配置管理）

### 前端技术栈

- **框架**：Vue3 + TypeScript
- **状态管理**：Pinia
- **UI 组件**：Element Plus / Naive UI
- **构建工具**：Vite

## 最佳实践

### 1. 服务拆分粒度

- ✅ 避免过度拆分，每个服务应能独立完成一个完整的业务功能
- ✅ 考虑复用性，服务应能被其他系统复用
- ✅ 平衡维护成本，服务数量应与团队规模相匹配

### 2. 数据一致性

- 采用最终一致性原则
- 使用分布式事务或补偿机制
- 合理设计数据同步策略

### 3. 服务治理

- 实现服务健康检查
- 建立完整的监控体系
- 制定服务降级策略
- 实现熔断和限流机制

### 4. 安全性

- JWT 认证
- 接口鉴权
- 数据加密
- 防止 SQL 注入

## 部署架构

```
                        ┌─────────────┐
                        │   Nginx     │
                        │  (反向代理)  │
                        └──────┬──────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
           ┌────▼────┐                   ┌───▼────┐
           │Blog API │                   │Admin API│
           │ :9090   │                   │ :9091   │
           └────┬────┘                   └────┬────┘
                │                             │
                └──────────────┬──────────────┘
                               │ gRPC 调用
                          ┌────▼────┐
                          │Blog RPC │
                          │ :9099   │
                          └────┬────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        │                      │                      │
   ┌────▼────┐           ┌────▼────┐           ┌────▼────┐
   │  MySQL  │           │  Redis  │           │RabbitMQ │
   │  :3306  │           │  :6379  │           │  :5672  │
   └─────────┘           └─────────┘           └─────────┘
```

### 端口说明

| 服务          | 端口    | 说明            |
|-------------|-------|---------------|
| Blog API    | 9090  | 博客前台 HTTP 接口  |
| Admin API   | 9091  | 管理后台 HTTP 接口  |
| Blog RPC    | 9090  | RPC 服务（内部调用）  |
| MySQL       | 3306  | 数据库服务         |
| Redis       | 6379  | 缓存服务          |
| RabbitMQ    | 5672  | 消息队列服务        |
| RabbitMQ 管理 | 15672 | RabbitMQ 管理界面 |

## 架构总结

微服务架构不是银弹，需要根据实际业务场景和团队能力进行合理设计。

### 关键要素

1. **服务划分**
    - 按业务领域划分，避免过度拆分
    - 保持服务高内聚低耦合
    - 考虑服务的复用性和扩展性

2. **数据管理**
    - 采用最终一致性原则
    - 合理设计数据同步策略
    - 避免分布式事务的复杂性

3. **服务治理**
    - 实现健康检查和服务发现
    - 建立完整的监控和告警体系
    - 制定服务降级和熔断策略

4. **团队协作**
    - 明确服务责任边界
    - 建立统一的开发规范
    - 完善文档和接口约定

### 适用场景

- ✅ 业务复杂度高，需要模块化管理
- ✅ 团队规模较大，需要并行开发
- ✅ 对可用性和扩展性要求高
- ✅ 不同模块有不同的技术需求

### 不适用场景

- ❌ 业务逻辑简单，单体应用已足够
- ❌ 团队规模小，维护成本高
- ❌ 对性能要求极高，无法接受网络开销
- ❌ 缺乏微服务治理经验和基础设施

## 参考资料

- [Go-Zero 官方文档](https://go-zero.dev/)
- [微服务架构设计模式](https://microservices.io/)
- [分布式系统原理](https://www.distributed-systems.net/)
