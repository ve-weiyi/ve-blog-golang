# MySQL 数据库设计规范

## 规范背景与目的

MySQL 数据库与 Oracle、SQL Server 等数据库相比，有其内核上的优势与劣势。本规范旨在帮助技术人员做出适合线上业务的数据库设计，在数据库变更和处理流程、数据库表设计、SQL
编写等方面予以规范，从而为业务系统稳定、健康地运行提供保障。

## 规范级别说明

| 级别        | 说明          | 处理方式     |
|-----------|-------------|----------|
| 🔴 **高危** | 严重影响性能或数据安全 | DBA 强制打回 |
| 🟠 **强制** | 必须遵守的规范     | DBA 强制打回 |
| 🟡 **建议** | 推荐遵守的最佳实践   | 建议采纳     |

## MySQL 使用场景

### ✅ 适用场景

- ✅ 需要做复杂处理的数据
- ✅ 单表数据量低于亿级别的数据
- ✅ 事务性强，安全性要求高的数据
- ✅ 数据格式单一的数据（字段格式固定）

### ❌ 不适用场景

- ❌ 高并发场景（建议使用 Redis、MongoDB）
- ❌ 在线实时分析场景（建议使用 ClickHouse、Elasticsearch）
- ❌ 海量数据场景（建议分库分表或使用大数据方案）
- ❌ 图片、文件、二进制数据（建议使用对象存储 OSS）
- ❌ 短生命周期数据（建议使用 Redis）

## 数据库设计规范

### 库名规范

1. 🟠 **强制** 库名必须控制在 32 个字符以内
2. 🟠 **强制** 库名格式：`业务系统名称_子系统名`
    - 示例：`blog_veweiyi`、`user_center`
3. 🟠 **强制** 分库命名格式：`库通配名_编号`
    - 按编号分库：`blog_001`、`blog_002`
    - 按时间分库：`blog_202401`、`blog_202402`

### 表结构规范

1. 🟠 **强制** 表名和列名必须控制在 32 个字符以内，只能使用字母、数字和下划线，一律小写
2. 🟠 **强制** 表名要求模块名强相关，使用统一前缀
    - 示例：`t_user`、`t_article`、`t_comment`
3. 🟠 **强制** 建表必须有 `COMMENT` 注释
4. 🟡 **建议** 主键设计
    - 主键字段名为 `id`，类型为 `bigint unsigned`，且为 `AUTO_INCREMENT`
    - 业务主键（如 `user_id`、`order_id`）建立 `UNIQUE KEY` 索引
    - 原因：随机主键会导致 InnoDB 内部 page 分裂和大量随机 I/O
5. 🟡 **建议** 必须有时间字段
    - `created_at` - 创建时间
    - `updated_at` - 更新时间
    - `deleted_at` - 软删除时间（可选）
6. 🟡 **建议** 所有字段设置为 `NOT NULL`，并定义 `DEFAULT` 值
    - 原因：NULL 值占用额外存储空间，影响聚合函数计算
7. 🟡 **建议** 大字段垂直拆分
    - 将 `blob`、`text` 等大字段拆分到其他表
    - 仅在需要时才查询这些字段
8. 🟡 **建议** 反范式设计
    - 把经常 join 查询的字段冗余一份
    - 示例：`user_name` 在 `t_article`、`t_comment` 表中冗余
9. 🟠 **强制** 大表 DDL 操作
    - 超过 100W 行的表执行 `ALTER TABLE` 必须经过 DBA 审核
    - 必须在业务低峰期执行
    - 原因：会产生表锁，阻塞所有写入操作

### 数据类型规范

1. 🟡 **建议** 状态字段使用 `tinyint` 或 `smallint`
    - 示例：`status tinyint NOT NULL DEFAULT 0 COMMENT '状态：0-禁用，1-启用'`
2. 🟡 **建议** IP 地址使用 `int` 类型
    - 原因：`int` 占 4 字节，`char(15)` 占 15 字节
    - 转换函数：`INET_ATON()`、`INET_NTOA()`
3. 🟡 **建议** 不推荐使用 `enum`、`set`
    - 原因：枚举值写死，变更不方便
    - 推荐：使用 `tinyint` 或 `smallint` + 注释说明
4. 🟡 **建议** 不推荐使用 `blob`、`text`
    - 原因：浪费硬盘和内存空间，影响性能
    - 建议：评估是否真的需要大字段
5. 🟡 **建议** 金额字段使用 `int` 或 `bigint`
    - 程序端乘以 100 存储（分为单位）
    - 原因：避免浮点数精度问题
6. 🟡 **建议** 文本数据使用 `varchar`
    - `varchar` 是变长存储，比 `char` 更省空间
    - 建议字符数不超过 2700
7. 🟡 **建议** 时间类型使用 `timestamp` 或 `int`
    - `timestamp` 占 4 字节，范围：1970-2038
    - `datetime` 占 8 字节，范围更大
    - 高阶方法：使用 `int` 存储时间戳

### 索引设计规范

1. 🟠 **强制** InnoDB 表必须有主键 `id int/bigint auto_increment`，且主键值禁止被更新
2. 🟡 **建议** 索引命名规范
    - 主键：`pk_字段名`
    - 唯一键：`uk_字段名`
    - 普通索引：`idx_字段名`
3. 🟠 **强制** 单个索引记录长度不能超过 64KB
4. 🟡 **建议** 单个表上的索引个数不超过 5 个
5. 🟡 **建议** 联合索引设计
    - 把区分度最高的字段放在最前面
    - 区分度计算：`SELECT COUNT(DISTINCT column_name) FROM table`
6. 🟡 **建议** 多表 join 时，被驱动表的连接列上必须有索引
7. 🟡 **建议** 避免冗余索引
    - 如果存在 `KEY(a,b)`，则 `KEY(a)` 为冗余索引

### 分库分表规范

**什么情况下需要分库分表**

1. 表大于 5G 或行数大于 5000W，以单表主键等简单形式访问数据
2. 表大于 5G 或行数大于 1000W，以两表 join、小范围查询等形式访问数据
3. 表大于 5G 或行数大于 500W，以多表 join、范围查询、order by、group by 等复杂形式访问数据
4. 表的字段中含有 text 等大字段、varchar(500) 以上的字段，拆分成父子表
5. 数据有时间过期特性的，需要做数据分表归档处理

**分区规范**

1. 🟠 **强制** 分区字段必须有索引，或者是组合索引的首列
2. 🟠 **强制** 单个分区表中的分区个数不能超过 1024
3. 🟠 **强制** 上线前 DBA 必须指定分区表的创建、清理策略
4. 🟠 **强制** 访问分区表的 SQL 必须包含分区键
5. 🟠 **强制** 分区表执行 `ALTER TABLE` 必须在业务低峰期执行
6. 🟠 **强制** 采用分库策略的，库的数量不能超过 1024
7. 🟠 **强制** 采用分表策略的，表的数量不能超过 4096
8. 🟡 **建议** 单个分表不超过 1000W 行
9. 🟡 **建议** 水平分表使用取模方式，日志、报表类数据使用日期分表

### 规范的建表示例

```sql
CREATE TABLE t_user_info (
                             `id`                 bigint(64) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id',
                             `user_id`            bigint(11) NOT NULL DEFAULT 0 COMMENT '用户id',
                             `user_name`          varchar(45)  NOT NULL DEFAULT '' COMMENT '真实姓名',
                             `birthday`           date         NOT NULL DEFAULT '1970-01-01' COMMENT '生日',
                             `sex`                tinyint(4) NOT NULL DEFAULT 0 COMMENT '性别：0-未知，1-男，2-女',
                             `user_resume`        varchar(300) NOT NULL DEFAULT '' COMMENT '用户简历存放地址',
                             `user_register_ip`   int          NOT NULL DEFAULT 0 COMMENT '用户注册时的源ip',
                             `user_review_status` tinyint      NOT NULL DEFAULT 4 COMMENT '用户资料审核状态：1-通过，2-审核中，3-未通过，4-未提交',
                             `created_at`         timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                             `updated_at`         timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
                             PRIMARY KEY (`id`),
                             UNIQUE KEY `uk_user_id` (`user_id`),
                             KEY                  `idx_user_name` (`user_name`),
                             KEY                  `idx_created_status` (`created_at`, `user_review_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='网站用户基本信息';
```

## SQL 编写规范

### DML 语句规范

1. 🟠 **强制** SELECT 语句必须指定具体字段名称，禁止写成 `*`
    - 原因：减少网卡压力，避免表结构变更导致的问题
2. 🟠 **强制** INSERT 语句指定具体字段名称，不要写成 `INSERT INTO t1 VALUES(...)`
3. 🟡 **建议** 批量插入时，单次插入的值不要超过 5000 个
    - 示例：`INSERT INTO t1 (a,b) VALUES (1,2), (3,4), ...`
    - 原因：值过多会引起主从同步延迟
4. 🟡 **建议** 使用 `UNION ALL` 代替 `UNION`
    - 原因：`UNION ALL` 不需要去重，性能更好
    - `UNION` 子句个数限制在 5 个以内
5. 🟡 **建议** IN 值列表限制在 500 以内
    - 示例：`SELECT * FROM t1 WHERE user_id IN (1,2,3,...)`
6. 🟡 **建议** 事务里批量更新数据需要控制数量，进行必要的 sleep
7. 🟠 **强制** DML 语句必须有 WHERE 条件，且使用索引查找（100 行以内的小表除外）
8. 🟠 **强制** 生产环境禁止使用 hint
    - 如：`sql_no_cache`、`force index`、`ignore key`、`straight join`
    - 原因：要相信 MySQL 优化器
9. 🟠 **强制** WHERE 条件里等号左右字段类型必须一致
10. 🟠 **强制** 查询数据量不要超过表行数的 25%
11. 🟠 **强制** WHERE 子句中禁止只使用全模糊的 LIKE 条件
    - 错误：`WHERE name LIKE '%admin%'`
    - 正确：`WHERE name LIKE 'admin%'`
12. 🟡 **建议** 索引列不要使用函数或表达式
    - 错误：`WHERE LENGTH(name) = 5`
    - 正确：`WHERE name = 'admin'`
13. 🟡 **建议** 减少使用 OR 语句，可优化为 UNION
    - 优化前：`WHERE a=1 OR b=2`
    - 优化后：`WHERE a=1 UNION WHERE b=2`
14. 🟡 **建议** 分页查询优化
    - 优化前：`SELECT * FROM t1 LIMIT 10000, 20`
    - 优化后：`SELECT * FROM t1 WHERE id > 10000 LIMIT 20`

### 多表连接规范

1. 🟠 **强制** 禁止在更新类 SQL 中使用 join
    - 错误：`UPDATE t1 JOIN t2 ON t1.id=t2.id SET ...`
2. 🟡 **建议** 不建议使用子查询，建议拆开或使用 join
3. 🟡 **建议** 线上环境，多表 join 不要超过 3 个表
4. 🟡 **建议** 多表连接查询推荐使用别名
    - 示例：`SELECT a.name FROM db1.t_user a WHERE ...`
5. 🟡 **建议** 选取结果集较小的表作为驱动表

### 事务规范

1. 🟡 **建议** 事务中操作的行数控制在 2000 以内
2. 🟡 **建议** 批量操作时，控制事务处理间隔时间，进行必要的 sleep（5-10 秒）
3. 🟡 **建议** 事务里包含的 SQL 不超过 5 个（支付业务除外）
4. 🟡 **建议** 事务里更新语句尽量基于主键或 unique key
    - 原因：避免产生间隙锁，导致死锁
5. 🟡 **建议** 把外部调用移出事务
    - 如：调用 webservice、访问文件存储等
6. 🟡 **建议** 对主从延迟敏感的 SELECT 语句，开启事务强制访问主库

### 排序和分组规范

1. 🟡 **建议** 减少使用 `ORDER BY`、`GROUP BY`、`DISTINCT`
    - 原因：这些语句较为耗费 CPU
    - 建议：能不排序就不排序，或将排序放到程序端
2. 🟡 **建议** 尽量利用索引直接检索出排序好的数据
    - 示例：`WHERE a=1 ORDER BY b` 可以利用 `KEY(a,b)`
3. 🟡 **建议** WHERE 条件过滤出来的结果集保持在 1000 行以内

### 禁止使用的 SQL

1. 🔴 **高危** 禁用带 LIMIT 的更新语句
    - 错误：`UPDATE t1 SET ... WHERE a=1 LIMIT 10`
    - 原因：会导致主从不一致
    - 建议：加上 `ORDER BY PK`
2. 🔴 **高危** 禁止使用关联子查询
    - 错误：`UPDATE t1 SET ... WHERE name IN (SELECT name FROM t2 WHERE ...)`
    - 原因：效率极其低下
3. 🟠 **强制** 禁用 procedure、function、trigger、views、event、外键约束
    - 原因：消耗数据库资源，降低可扩展性
    - 建议：在程序端实现
4. 🟠 **强制** 禁用 `INSERT INTO ... ON DUPLICATE KEY UPDATE`
    - 原因：高并发环境下会造成主从不一致
5. 🟠 **强制** 禁止联表更新语句
    - 错误：`UPDATE t1, t2 SET ... WHERE t1.id=t2.id`

## 数据库平台使用规范

1. 🟠 **强制** SQL 上线前必须先审核，根据提示修改
2. 🟠 **强制** SQL 查询前先查看执行计划，确认是否走索引
3. 🟡 **建议** 多表关联必须带 WHERE 条件

## 参考资料

- [MySQL 官方文档](https://dev.mysql.com/doc/)
- [阿里巴巴 Java 开发手册 - MySQL 数据库规约](https://github.com/alibaba/p3c)
- [高性能 MySQL](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/)
