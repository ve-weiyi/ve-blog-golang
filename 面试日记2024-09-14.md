1. make和new的区别？
 make 只能用于三种内建的引用类型：slice（切片）、map（映射）、channel（通道）。它分配和初始化这些引用类型的数据结构，并返回该类型（而不是指针）。
 new 只能用于基础类型（int、float、struct 等），不会进行初始化，并且返回指针。

2. 切片的底层结构是什么？切片是如何扩容的？
切片的底层结构是一个结构体，包含有三个属性（指针，长度，容量）。
当切片的容量不足时，会重新分配一个更大的底层数组，并将原来的数据拷贝到新的数组中。

3. map的底层结构是什么？
map的底层结构是一个桶数组，哈希函数会将每个键的哈希值映射到一个特定的桶内。查找时通过哈希函数直接找到下标。
桶的结构包含有（hash、key、value、next）

4. map的key允许哪些类型？
map 的键（key）必须是可比较的类型，因为 map 使用哈希函数来计算键的哈希值，并需要对键进行比较以确保唯一性。因此，map 键的类型必须支持 == 和 != 操作符。
允许：整型、浮点型、布尔、字符串、指针、结构体（所有字段可比较）和数组。
m不允许：slice、map、function、interface类型

5. 有哪些锁类型，锁的底层结构是什么？
互斥锁（sync.Mutex）：用于确保同一时刻只有一个协程可以访问某个共享资源。其他尝试获取锁的协程会被阻塞，直到锁被释放。
读写锁（sync.RWMutex）:允许多个读操作同时进行，但写操作是独占的。当一个协程正在执行写操作时，其他协程的读写操作都会被阻塞。
```go
type Mutex struct {
state int32  // 状态，表示锁的状态（是否被持有，是否有等待的协程）
sema  uint32 // 信号量，用于协调锁的获取和释放
}

type RWMutex struct {
w           Mutex  // 控制写锁的互斥锁
writerSem   uint32 // 写操作的信号量
readerSem   uint32 // 读操作的信号量
readerCount int32  // 当前持有读锁的协程数量
readerWait  int32  // 等待获取读锁的协程数量
}
```
sema 实际上是一个计数器，这个计数器会在锁释放时进行递增（表示资源可用），在锁被占用时进行递减。

6. Mysq不等于为什么不走索引？
因为 != 或者 <> 会返回除去某个特定值以外的所有记录，这种查询往往涉及大量行，因此 MySQL 优化器可能会认为全表扫描更为高效。

7. Redis分布式锁如何设计
步骤：
尝试获取锁时，使用 SETNX 命令为某个键（锁）设置一个唯一的标识值。
如果 SETNX 成功（返回 1），表示获取锁成功，并通过 EXPIRE 设置一个自动过期时间，防止死锁。
如果 SETNX 失败（返回 0），则表示锁已经被其他客户端持有，当前客户端可以选择重试或退出。
释放锁时，验证锁的标识值是否为当前客户端的值，确保只有持有锁的客户端能够释放锁。

8. 什么是缓存雪崩、缓存击穿、缓存穿透？
   https://cloud.tencent.com/developer/article/2418793
缓存雪崩是指在某一时刻，大量的缓存数据同时失效，导致大量的请求直接打到数据库上
缓存击穿是指一个存在的数据在缓存中过期，导致所有的请求都直接打到数据库，造成数据库短时间内压力过大。这种现象被称为缓存击穿。
缓存穿透是指查询一个数据库中不存在的数据，由于缓存中也没有，所以每次查询都会直接访问数据库。如果有大量此类请求，就会对数据库造成很大压力，这种现象被称为缓存穿透。


笔试题：
快速排序算法


哨兵法：左边找大，右边找小。交换与哨兵的位置，哨兵的值不变。直到左右指针相遇，交换哨兵与相遇位置的值。
左右指针法：都是取第一个为基准，从右找小，再从左边找大，交换左右位置。最后基准与左指针换位。与哨兵方法相同，区别是找到大小值时同时交换位置，不需要中间步骤。
前后指针法：前后指针法。前指针找小，后指针交换。注意 	l := low ；for r := low + 1; r <= high; r++ 
